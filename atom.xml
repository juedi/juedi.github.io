<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Juedi's blog]]></title>
  <subtitle><![CDATA[吾当绝地而行，纵万里而不知倦也]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xwx517.com/"/>
  <updated>2014-12-22T15:52:04.284Z</updated>
  <id>http://xwx517.com/</id>
  
  <author>
    <name><![CDATA[duliao]]></name>
    <email><![CDATA[duliao116@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[李雷说英语(1)]]></title>
    <link href="http://xwx517.com/2014/12/22/%E6%9D%8E%E9%9B%B7%E8%AF%B4%E8%8B%B1%E8%AF%AD-1/"/>
    <id>http://xwx517.com/2014/12/22/李雷说英语-1/</id>
    <published>2014-12-22T15:09:57.000Z</published>
    <updated>2014-12-22T15:51:45.000Z</updated>
    <content type="html"><![CDATA[<p>大学毕业多年之后的今天，哦不，确切说是高中毕业后多年之后，虽然在工作中也要看各种的英文文档，查找英文的技术资料，但早已忘记了英语的语序啊、结构啊之类的基本概念，大部分的理解已经是靠经验，觉得“大概就是这么个意思”，“这些单词放在一起就该这么翻译”……当然，这也是因为英语在工作、生活中虽然必不可少，但却可以“不求甚解”的外部环境造成的。前些日子偶尔看到优酷视频的一个自媒体节目<a href="http://v.youku.com/v_show/id_XNjc0Mzc1MTk2.html" target="_blank" rel="external">《李雷说英语》</a>，作者的用心之处自不必说，其节目的趣味性和学习效果也是刚刚的，从今天起，决定每集都看一看，重新回归，从基础语法结构学习，记录学习笔记。</p>
<h2 id="主谓结构(一物一动作)">主谓结构(一物一动作)</h2>
<ol>
<li>主语：主语都是名词，名词包含代词(I\She\It\He\They)</li>
<li>谓语：名词后面的动词(暂时如此解释)</li>
<li>主谓结构的中文句子都可以直接翻译成英文。<ol>
<li>他死了(He died)。</li>
<li>网络任务消失了(The network tasks disappeared)。</li>
</ol>
</li>
<li>将主谓结构的简单句子变成长句。<ol>
<li>adj. 修饰 n.</li>
<li>adv. 修饰 v.</li>
<li>时间地点写句末</li>
<li>简单句子：A man died. 长句：adj+主+谓+adv+时间+地点。例句：A young man died mysteriously in this hotel last night. A young girl fainted suddenly in the bathroom just now.</li>
</ol>
</li>
<li>如何判断一个词是副词？<ol>
<li>背单词时记住词性。</li>
<li>“突然”是什么词性？在“突然”后面加上“小孩”|“晕倒”，发现“突然小孩”句子不同，“突然晕倒”句子通顺，而小孩是名词，晕倒是动词，形容词修饰名词，副词修饰动词，这么判断的话很明显“突然”就是副词了。</li>
</ol>
</li>
<li>副词修饰谓语放在结构后方：主谓副，主谓宾副</li>
<li>动词分类：<ol>
<li>vt 及物动词 不用在主谓结构中 和它后面的名词是不可拆分的整体</li>
<li>vi 不及物动词</li>
</ol>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>大学毕业多年之后的今天，哦不，确切说是高中毕业后多年之后，虽然在工作中也要看各种的英文文档，查找英文的技术资料，但早已忘记了英语的语序啊、结构啊之类的基本概念，大部分的理解已经是靠经验，觉得“大概就是这么个意思”，“这些单词放在一起就该这么翻译”……当然，这也是因为英语在工]]>
    </summary>
    
      <category term="英语,笔记" scheme="http://xwx517.com/tags/%E8%8B%B1%E8%AF%AD-%E7%AC%94%E8%AE%B0/"/>
    
      <category term="李雷说英语" scheme="http://xwx517.com/categories/%E6%9D%8E%E9%9B%B7%E8%AF%B4%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Assert断言]]></title>
    <link href="http://xwx517.com/2014/12/21/Assert%E6%96%AD%E8%A8%80/"/>
    <id>http://xwx517.com/2014/12/21/Assert断言/</id>
    <published>2014-12-21T08:22:29.000Z</published>
    <updated>2014-12-21T10:15:31.000Z</updated>
    <content type="html"><![CDATA[<p>最近，遇到一个计算生态补偿金额的业务，具体的计算公式是一个比较麻烦的东西，里面各种数据符号，什么Σ、Φ、α、β之类的玩意，对于我来说，好久不见这些东西，符号该怎么读都差不多忘记了，很是苦恼。最后终于跟客户弄清楚了，公式的意义，就开始编码计算。</p>
<p>公式的数据来源是数据库中查出来的，但数据库中的数据并非就是完整的、干净的，就是说我再处理α*β这类玩意的时候很有可能从数据库中查出来的是一个非数字字符串，或者null数据。那么问题来了，这样子去计算公式程序必然会报各种异常，然后跟客户反应后客户提出要求：运行公式前，先检查公式需要数据的完整性，如果公式需要的数据不符合要求，就在页面上给客户提示，哪些数据有问题。</p>
<h2 id="条件判断方式">条件判断方式</h2>
<p>将数据从数据库中查出，依次按照各个数据的校验条件进行校验，使用返回字符串的形式返回校验结果。</p>
<pre><code><span class="keyword">public</span> <span class="built_in">String</span> validate(){
<span class="built_in">String</span> errorInfo<span class="subst">=</span><span class="string">""</span>;
<span class="comment">//dataA from database</span>
<span class="keyword">if</span>(dataA <span class="subst">==</span> <span class="built_in">null</span>){<span class="comment">//或者其他条件要求，例如dataA必须为数字，数字范围在[1,20]等</span>
    errorInfo <span class="subst">=</span> <span class="string">"dataA 数据有误"</span>;
    <span class="keyword">return</span>;
}
<span class="comment">//dataB from database</span>
<span class="keyword">if</span>(dataB <span class="subst">==</span> <span class="built_in">null</span>){<span class="comment">//或者其他条件要求，例如dataA必须为数字，数字范围在[1,20]等</span>
    errorInfo <span class="subst">=</span> <span class="string">"dataB 数据有误"</span>;
    <span class="keyword">return</span>;
}
<span class="attribute">...</span>
<span class="comment">//校验完毕，开始执行公式计算</span>
}
</code></pre><p>这种方式就会有大量的检查代码，重复的逻辑判断<em>a==null</em>,<em>a is number</em>等，使代码看起来冗长切不易理解，校验代码和执行代码实际上就可以是两个不同的模块。</p>
<h2 id="ibatis方式">ibatis方式</h2>
<p>最近在看ibatis源代码时看到它在处理异常信息时使用了一种非常有趣的方式。首先，有一个保存错误信息的类ErrorContext:</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> ErrorContext {

  <span class="keyword">private</span> String resource;
  <span class="keyword">private</span> String activity;
  <span class="keyword">private</span> String objectId;
  <span class="keyword">private</span> String moreInfo;
  <span class="keyword">private</span> Throwable cause;
 <span class="comment">//setter</span>
 <span class="comment">//getter</span>
  <span class="keyword">public</span> String toString() {
    StringBuffer message = <span class="keyword">new</span> StringBuffer();
    <span class="comment">// resource</span>
    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) {
      message.<span class="keyword">append</span>(<span class="string">"  \n--- The error occurred in "</span>);
      message.<span class="keyword">append</span>(resource);
      message.<span class="keyword">append</span>(<span class="string">"."</span>);
    }    
    <span class="comment">// activity</span>
    <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {
      message.<span class="keyword">append</span>(<span class="string">"  \n--- The error occurred while "</span>);
      message.<span class="keyword">append</span>(activity);
      message.<span class="keyword">append</span>(<span class="string">"."</span>);
    }
    <span class="comment">// object</span>
    <span class="keyword">if</span> (objectId != <span class="keyword">null</span>) {
      message.<span class="keyword">append</span>(<span class="string">"  \n--- Check the "</span>);
      message.<span class="keyword">append</span>(objectId);
      message.<span class="keyword">append</span>(<span class="string">"."</span>);
    }
    <span class="comment">// more info</span>
    <span class="keyword">if</span> (moreInfo != <span class="keyword">null</span>) {
      message.<span class="keyword">append</span>(<span class="string">"  \n--- "</span>);
      message.<span class="keyword">append</span>(moreInfo);
    }
    <span class="comment">// cause</span>
    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) {
      message.<span class="keyword">append</span>(<span class="string">"  \n--- Cause: "</span>);
      message.<span class="keyword">append</span>(cause.toString());
    }
    <span class="keyword">return</span> message.toString();
  }
  <span class="keyword">public</span> <span class="keyword">void</span> reset() {
    resource = <span class="keyword">null</span>;
    activity = <span class="keyword">null</span>;
    objectId = <span class="keyword">null</span>;
    moreInfo = <span class="keyword">null</span>;
    cause = <span class="keyword">null</span>;
  }    
}
</code></pre><p>然后在程序中使用时，直接在执行每一步关键代码的前面set校验信息，如果程序的下一步出现异常，那就跳到catch块中，将具体的异常信息保存到ErrorContext对象中，最终在处理异常时，就可以将详细的异常信息展示出来：</p>
<pre><code><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeQueryWithCallback</span>(StatementScope statementScope, Connection conn, Object parameterObject, Object resultObject, RowHandler rowHandler, <span class="keyword">int</span> skipResults, <span class="keyword">int</span> maxResults)
  <span class="keyword">throws</span> SQLException {
<span class="comment">//开始设置异常信息</span>
ErrorContext errorContext = statementScope.getErrorContext();
errorContext.setActivity(<span class="string">"preparing the mapped statement for execution"</span>);
errorContext.setObjectId(<span class="keyword">this</span>.getId());
errorContext.setResource(<span class="keyword">this</span>.getResource());

<span class="keyword">try</span> {
  parameterObject = validateParameter(parameterObject);

  Sql sql = getSql();
  <span class="comment">//执行代码前设置异常信息</span>
  errorContext.setMoreInfo(<span class="string">"Check the parameter map."</span>);
  ParameterMap parameterMap = sql.getParameterMap(statementScope, parameterObject);

  errorContext.setMoreInfo(<span class="string">"Check the result map."</span>);
  ResultMap resultMap = sql.getResultMap(statementScope, parameterObject);

  statementScope.setResultMap(resultMap);
  statementScope.setParameterMap(parameterMap);

  errorContext.setMoreInfo(<span class="string">"Check the parameter map."</span>);
  Object[] parameters = parameterMap.getParameterObjectValues(statementScope, parameterObject);

  errorContext.setMoreInfo(<span class="string">"Check the SQL statement."</span>);
  String sqlString = sql.getSql(statementScope, parameterObject);

  errorContext.setActivity(<span class="string">"executing mapped statement"</span>);
  errorContext.setMoreInfo(<span class="string">"Check the SQL statement or the result map."</span>);
  RowHandlerCallback callback = <span class="keyword">new</span> RowHandlerCallback(resultMap, resultObject, rowHandler);
  sqlExecuteQuery(statementScope, conn, sqlString, parameters, skipResults, maxResults, callback);

  errorContext.setMoreInfo(<span class="string">"Check the output parameters."</span>);
  <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span>) {
    postProcessParameterObject(statementScope, parameterObject, parameters);
  }

  errorContext.reset();
  sql.cleanup(statementScope);
  notifyListeners();
} <span class="keyword">catch</span> (SQLException e) {
  <span class="comment">//异常信息保存近errorContext对象中</span>
  errorContext.setCause(e);
  <span class="keyword">throw</span> <span class="keyword">new</span> NestedSQLException(errorContext.toString(), e.getSQLState(), e.getErrorCode(), e);
} <span class="keyword">catch</span> (Exception e) {
  errorContext.setCause(e);
  <span class="keyword">throw</span> <span class="keyword">new</span> NestedSQLException(errorContext.toString(), e);
}
}
</code></pre><p><em>这种方式的好处就是不必挨个的去使用if语句判断，只需要在合适的地方加上错误信息的保存，程序的正常执行逻辑不变，当正常执行逻辑出现异常时，自然就会中断，然后此时保存的异常信息就是最近的信息。<br>当然，这种方式处理较为复杂的条件判断是就会比较麻烦，比如:a的数字范围是[10,20]，如果a的数值为30，带入到公式中，公式也是可以计算的，不会出现异常。</em></p>
<h2 id="spring方式">spring方式</h2>
<p>使用过Spring的同学想必就见过这样的代码:</p>
<pre><code>public <span class="type">void</span> addCallback(<span class="type">ListenableFutureCallback</span>&lt;? super T&gt; callback) {
    <span class="type">Assert</span>.notNull(callback, <span class="string">"'callback' must not be null"</span>);
    synchronized (mutex) {
        switch (state) {
            <span class="keyword">case</span> <span class="type">NEW</span>:
                callbacks.add(callback);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="type">SUCCESS</span>:
                callback.onSuccess((T)<span class="literal">result</span>);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="type">FAILURE</span>:
                callback.onFailure((<span class="type">Throwable</span>) <span class="literal">result</span>);
                <span class="keyword">break</span>;
        }
    }
}
</code></pre><p>Spring中的很多操作的一开始都有这么一个断言Assert.notNull()，那么这个notNull()方法是什么呢？</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notNull</span>(Object <span class="keyword">object</span>, String message) {
    <span class="keyword">if</span> (<span class="keyword">object</span> == <span class="keyword">null</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(message);
    }
}

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notNull</span>(Object <span class="keyword">object</span>) {
    notNull(<span class="keyword">object</span>, <span class="string">"[Assertion failed] - this argument is required; it must not be null"</span>);
}
</code></pre><p>可以看出，如果断言失败，那么程序就会抛出异常，这是非常严格的校验方式了。看到这里，有人也行会问，这根我们的校验有什么关系，我们是要返回具体的校验信息的。到这里，我们其实可以看出，假如我们想要返回具体的校验信息，只需要综合ibatis和spring的异常处理方式，在Assert之前把错误信息set近Context中就行了:</p>
<pre><code>public String validate(){
<span class="keyword">try</span>{
    //dataA from database
    errorContext.setErrorInfo(<span class="string">"数据A不能为空"</span>);
    Assert.notNull(dataA);
    errorContext.setErrorInfo(<span class="string">"数据范围为[10,20]"</span>);
    Assert.range(<span class="number">10</span>,<span class="number">20</span>);
}catch(Exception e){
    //返回异常信息
    <span class="keyword">return</span> errorContext.toString();
}
<span class="keyword">...</span>
//校验完毕，开始执行公式计算
}
</code></pre><p>这样，既避免的代码重复，逻辑混乱，也可以更好的返回详细信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近，遇到一个计算生态补偿金额的业务，具体的计算公式是一个比较麻烦的东西，里面各种数据符号，什么Σ、Φ、α、β之类的玩意，对于我来说，好久不见这些东西，符号该怎么读都差不多忘记了，很是苦恼。最后终于跟客户弄清楚了，公式的意义，就开始编码计算。</p>
<p>公式的数据来源是]]>
    </summary>
    
      <category term="Assertion,异常信息" scheme="http://xwx517.com/tags/Assertion-%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF/"/>
    
      <category term="代码艺术" scheme="http://xwx517.com/categories/%E4%BB%A3%E7%A0%81%E8%89%BA%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://xwx517.com/2014/12/21/hello-world/"/>
    <id>http://xwx517.com/2014/12/21/hello-world/</id>
    <published>2014-12-21T04:03:45.000Z</published>
    <updated>2014-12-11T15:03:28.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客之旅]]></title>
    <link href="http://xwx517.com/2014/12/16/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    <id>http://xwx517.com/2014/12/16/博客之旅/</id>
    <published>2014-12-16T15:26:40.000Z</published>
    <updated>2014-12-17T14:24:39.000Z</updated>
    <content type="html"><![CDATA[<p>从今天起，也算是开始学会使用Github作为个人博客的平台了。忙活了半天，也用Hexo把基本的博客框架搭建了起来，貌似还是很好用的，不过我才只学会了一点点基本的应用，接下来就是要好好学习下这玩意怎么搞才方便，有能力的话还是自己搞一套皮肤才好玩，毕竟玩这个的就是追求个性。当然了，我不同与那群大牛的是，我以前基本没写过博客，虽然以前叨叨着写这写那的，可总是懒得动手，这次既然费劲把这个弄好了，那以后说什么也得多总结、多记录写心得体会啥的，不能让这番功夫白费了！</p>
<p>姑且自勉之！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从今天起，也算是开始学会使用Github作为个人博客的平台了。忙活了半天，也用Hexo把基本的博客框架搭建了起来，貌似还是很好用的，不过我才只学会了一点点基本的应用，接下来就是要好好学习下这玩意怎么搞才方便，有能力的话还是自己搞一套皮肤才好玩，毕竟玩这个的就是追求个性。当然]]>
    </summary>
    
      <category term="随笔" scheme="http://xwx517.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
